# S_2805 문제 분석 보고서

## 문제 개요

정사각형 형태의 농지에서 **마름모 모양의 영역**에 있는 모든 숫자를 합하는 문제입니다. 마름모의 중심은 정사각형의 중심이고, 마름모의 크기는 중심으로부터의 맨해튼 거리(Manhattan Distance)로
결정됩니다.

---

## 입력(Input)

```
T (테스트 케이스 개수)
[각 테스트 케이스마다]
N (정사각형 농지의 한 변의 길이)
N줄의 N개 숫자 (공백 없이 붙어있는 한 자리 숫자)
```

**예시:**

```
1
5
12345
54321
97531
24687
13579
```

---

## 출력(Output)

```
#T 마름모_영역의_합
```

**예시:**

```
#1 74
```

---

## 제약 사항

- 1 ≤ T ≤ 10 (테스트 케이스 개수)
- 5 ≤ N ≤ 999 (홀수만 가능, 정사각형 농지의 한 변)
- 0 ≤ 각 셀의 값 ≤ 9 (한 자리 숫자)

---

## 문제 접근 방법

### 핵심 개념

**마름모(Diamond/Rhombus)**: 중심 좌표로부터 맨해튼 거리(Manhattan Distance)가 `N/2` 이하인 모든 점의 합을 구하는 것

**맨해튼 거리 공식:**

```
distance = |i - center| + |j - center|
```

### 두 솔루션의 접근 방식 비교

#### 1️⃣ **이태호 솔루션: 좌표 기반 마름모 판정 (Coordinate-based)**

- 전체 배열을 순회하면서 **각 셀이 마름모 내부인지 확인**
- 맨해튼 거리를 계산하여 범위 내 값만 합산
- 반복문 기반, 직관적인 접근

**로직:**

```java
center =n /2;

        for(
int i = 0;
i<n;i++){
        for(
int j = 0;
j<n;j++){
        // 마름모에 속하는지 확인
        if((Math.

abs(i -center) +Math.

abs(j -center))<=center){
answer +=value;
        }
                }
                }
```

#### 2️⃣ **전효준 솔루션: 행 기반 동적 범위 계산 (Row-based Dynamic Range)**

- 각 행마다 마름모의 **시작과 끝 인덱스를 동적으로 계산**
- 상반부(중심까지): 범위 확대 (`start-1, end+1`)
- 하반부(중심 이후): 범위 축소 (`start+1, end-1`)
- 재귀 함수로 구현, 메모리 효율적

**로직:**

```java
if(row<center){
// 상반부: 범위 확대
nextStart =start -1;
nextEnd =end +1;
        }else{
// 하반부: 범위 축소
nextStart =start +1;
nextEnd =end -1;
        }
```

---

## 시간 복잡도

### 이태호 솔루션

- **시간 복잡도**: **O(N²)**
    - 2중 for 루프로 모든 셀 방문: O(N²)
    - 각 셀마다 맨해튼 거리 계산: O(1)
    - 총: O(N²) × O(1) = O(N²)
- **공간 복잡도**: **O(N²)** (2차원 배열 저장)

### 전효준 솔루션

- **시간 복잡도**: **O(N²)**
    - 마름모 영역의 셀 수만 방문: 약 ½N² (마름모 면적)
    - 각 행마다 일정 범위만 계산
    - 총: O(N²) (마름모 면적)
- **공간 복잡도**: **O(N²)** (2차원 배열) + **O(N)** (재귀 스택)

**성능**: 두 솔루션 모두 O(N²)이지만, **전효준 솔루션**이 필요한 셀만 방문하므로 실제로는 더 빠름

---

## 주의 사항

### ⚠️ 입력 처리 방식의 차이

| 항목        | 이태호            | 전효준              |
|-----------|----------------|------------------|
| **파싱 방식** | `split("")` 사용 | `charAt()` 직접 접근 |
| **성능**    | 느림 (배열 생성)     | 빠름 (1개씩 접근)      |
| **메모리**   | 높음             | 낮음               |

**권장**: `charAt()`가 더 효율적 (배열 생성 오버헤드 없음)

### ⚠️ N은 항상 홀수

- 중심이 정확히 한 점이 되려면 N은 홀수여야 함
- `center = n / 2` (정수 나눗셈)으로 올바르게 계산됨

### ⚠️ 문자열에서 숫자로의 변환

```java
// 이태호: 문자열 배열 생성 후 변환
Integer.parseInt(line[j]);

// 전효준: 문자 직접 변환 (더 효율적)
line.

charAt(j) -'0'
```

---

## 코드 상세 설명

### 이태호 솔루션 (S_2805_이태호.java)

```java
int center = n / 2;
int answer = 0;

for(
int i = 0;
i<n;i++){
String[] line = br.readLine().split("");  // 문자열을 배열로 변환

    for(
int j = 0;
j<n;j++){
        // 맨해튼 거리로 마름모 판정
        if((Math.

abs(i -center) +Math.

abs(j -center))<=center){
answer +=Integer.

parseInt(line[j]);  // 문자를 숫자로 변환하여 합산
        }
                }
                }
```

**장점**:

- 코드가 간단하고 직관적
- 마름모 조건이 명확함

**단점**:

- 모든 셀을 순회 (불필요한 연산)
- `split("")`로 배열 생성 (메모리 오버헤드)
- 문자 변환 과정이 번거로움

---

### 전효준 솔루션 (S_2805_전효준(찐).java)

```java
// 재귀 함수로 각 행의 합을 계산
public static int farmTest(int row, int start, int end, int currentSum) {
    if (row == N)
        return currentSum;

    int rowSum = 0;
    // 현재 행의 [start, end] 범위만 합산
    for (int j = start; j <= end; j++) {
        rowSum += farm[row][j];
    }

    int nextStart, nextEnd;
    int center = N / 2;

    // 상반부(중심 위): 범위 확대
    if (row < center) {
        nextStart = start - 1;
        nextEnd = end + 1;
    }
    // 하반부(중심 아래): 범위 축소
    else {
        nextStart = start + 1;
        nextEnd = end - 1;
    }

    return farmTest(row + 1, nextStart, nextEnd, currentSum + rowSum);
}
```

**로직 흐름:**

```
행 0 (중심): [2, 3] (1개)
행 1: [1, 4] (3개)
행 2 (중심): [0, 4] (5개) ← 최대 범위
행 3: [1, 4] (3개)
행 4: [2, 3] (1개)
```

**장점**:

- 마름모 영역만 정확히 순회
- 불필요한 연산 없음
- `charAt()` 사용으로 메모리 효율적
- 재귀로 우아한 구현

**단점**:

- 재귀 스택 추가 메모리 (O(N))
- 코드가 조금 더 복잡

---

## 마름모 영역 시각화

N=5인 경우 (center = 2):

```
    0 1 2 3 4
0   . . X . .
1   . X X X .
2   X X X X X
3   . X X X .
4   . . X . .

X = 마름모 영역
```

**행별 범위:**

- 행 0: [2, 2] (거리 2)
- 행 1: [1, 3] (거리 1)
- 행 2: [0, 4] (거리 0, 중심)
- 행 3: [1, 3] (거리 1)
- 행 4: [2, 2] (거리 2)

---

## 성능 비교 요약

| 항목          | 이태호             | 전효준            |
|-------------|-----------------|----------------|
| **시간복잡도**   | O(N²)           | O(N²)          |
| **공간복잡도**   | O(N²)           | O(N²) + O(N)   |
| **실제 셀 방문** | N² 개            | 약 ½N² 개        |
| **입력 처리**   | `split()`       | `charAt()`     |
| **구현 방식**   | 반복문 (Iterative) | 재귀 (Recursive) |
| **가독성**     | 높음              | 중간             |
| **메모리 효율**  | 낮음              | 높음             |

---

## 결론

### 이태호 방식의 장점

✅ 직관적이고 이해하기 쉬움  
✅ 맨해튼 거리 공식이 명확함

### 전효준 방식의 장점

✅ 마름모 영역만 효율적으로 순회  
✅ 입력 처리가 최적화됨 (`charAt()`)  
✅ 불필요한 연산 최소화  
✅ 대규모 입력(N=999)에서 성능 우수

**권장**: N이 크거나 성능이 중요한 경우 **전효준 방식** 추천. 단순 이해와 구현이 목표면 **이태호 방식** 추천.

