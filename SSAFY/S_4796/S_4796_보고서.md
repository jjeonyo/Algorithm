# S_4796 문제 분석 보고서

## 문제 개요

산의 높이 시퀀스에서 **봉우리(peak)의 개수**를 세는 문제.

---

## 입력(Input)

```
T (테스트 케이스 개수)
[각 테스트 케이스마다]
N (산의 개수)
N개의 정수 (각 산의 높이)
```

**예시:**

```
1
8
1 2 3 4 3 2 1 2
```

---

## 출력(Output)

```
#T 봉우리_개수
```

**예시:**

```
#1 3
```

---

## 제약 사항

- 1 ≤ T ≤ 10 (테스트 케이스 개수)
- 3 ≤ N ≤ 1000 (산의 개수)
- 1 ≤ 산의 높이 ≤ 1000

---

## 문제 접근 방법

### 핵심 개념

**봉우리(Peak)**: 올라가다가(증가) 내려가는(감소)로 상태가 바뀌는 지점의 개수를 세는 것

### 두 솔루션의 접근 방식 비교

#### 1️⃣ **이태호 솔루션: 상태 추적 방식(State Tracking)**

- 인접한 두 산의 높이를 비교하여 **올라가는 상태(true) / 내려가는 상태(false)** 를 boolean 배열에 저장
- 상태가 **true → false로 바뀌는 순간**이 봉우리 → 올라간 횟수를 누적하여 답에 더함
- 상태 변화의 **경계점에서만 계산**

**로직:**

```
mount[i] = true  → 높이가 증가 중
mount[i] = false → 높이가 감소 중

accum을 증가시키다가 
false 상태가 되면 → accum을 answer에 더함 (봉우리 완성)
```

#### 2️⃣ **전효준 솔루션: 연속 구간 계산 방식(Continuous Segment)**

- **연속된 올라가는 구간의 길이(up)** 와 **연속된 내려가는 구간의 길이(down)** 를 동시에 계산
- 한 번의 **up → down 사이클**이 완성되면: `up × down`을 결과에 더함
- 여러 봉우리가 연속될 경우 더 효율적으로 처리

**로직:**

```
while(올라가는 중) up++  → up 카운트
while(내려가는 중) down++ → down 카운트

if(up > 0 && down > 0)
    cnt += (up × down)  → 복합 봉우리 계산
```

---

## 시간 복잡도

### 이태호 솔루션

- **시간 복잡도**: **O(N)**
    - boolean 배열 생성: O(N-1)
    - 상태 추적: O(N-1)
    - 봉우리 계산: O(N-1)
- **공간 복잡도**: **O(N)** (boolean 배열)

### 전효준 솔루션

- **시간 복잡도**: **O(N)**
    - 입력 수신: O(N)
    - 봉우리 계산 (while 루프): O(N)
- **공간 복잡도**: **O(N)** (int 배열)

**결론**: 두 솔루션 모두 **O(N) 선형 시간**이지만, 전효준 솔루션이 **O(1) 추가 공간** 사용으로 약간 더 효율적

---

## 주의 사항

### ⚠️ 입력 처리의 차이

| 항목         | 이태호               | 전효준       |
|------------|-------------------|-----------|
| **입력 방식**  | `StreamTokenizer` | `Scanner` |
| **효율성**    | 더 빠름              | 일반적       |
| **코드 복잡도** | 약간 복잡             | 간단        |

### ⚠️ 알고리즘 선택 차이

- **이태호**: 상태 배열을 **먼저 생성** 후 처리 → 두 패스(Two-pass)
- **전효준**: 상태를 **즉시 계산** → 한 패스(One-pass) → 메모리 효율 좋음

### ⚠️ 복합 봉우리 처리

예제: `1 2 3 4 3 2 1 2 3`

- 이태호: `[true, true, true, false, false, false, true, true]`
  → 올라가기(3) × 내려가기(3) = 9가 아니라 **3**으로 계산
- 전효준: up=3, down=3 → `3 × 3 = 9`로 계산

**차이의 이유**: 이태호는 "봉우리의 개수"를, 전효준은 "모든 조합 경로의 수"를 계산

---

## 코드 상세 설명

### 이태호 솔루션 (S_4796_이태호.java)

```java
// 1단계: 상태 배열 구성
for(int i = 0;
i<mount.length;i++){
        st.

nextToken();

int b = (int) st.nval;
    if(b-a >0)mount[i]=true;   // 올라가는 중
        else mount[i]=false;          // 내려가는 중
a =b;
}

// 2단계: 상태 변화점 감지
        for(
int i = 0;
i<mount.length;i++){
        if(mount[i]){
        if(reset){
accum =0;
reset =false;
        }
accum++;        // 올라가는 중: 카운트 증가
        }else{
reset =true;   // 상태 리셋
answer +=accum;// 올라간 횟수를 결과에 더함
    }
            }
```

**핵심**: `reset` 플래그로 새로운 올라가는 구간의 시작을 감지

---

### 전효준 솔루션 (S_4796_전효준.java)

```java
public static void mountCount() {
    int i = 0;
    while (i < N - 1) {
        int up = 0;
        int down = 0;

        // 올라가는 구간 계산
        while (i < N - 1 && mounts[i] < mounts[i + 1]) {
            up++;
            i++;
        }

        // 내려가는 구간 계산
        while (i < N - 1 && mounts[i] > mounts[i + 1]) {
            down++;
            i++;
        }

        // 한 사이클 완성: up과 down의 곱
        if (up > 0 && down > 0) {
            cnt += (up * down);
        }

        // 평탄한 구간 처리
        if (up == 0 && down == 0) {
            i++;
        }
    }
}
```

**핵심**:

- 중첩 while 루프로 연속된 증가/감소 구간을 한 번에 처리
- `up × down` 계산으로 복합 경로의 수를 세기
- 평탄한 구간(높이 같음)은 건너뛰기

---

## 성능 비교 요약

| 항목           | 이태호        | 전효준          |
|--------------|------------|--------------|
| **시간복잡도**    | O(N)       | O(N)         |
| **공간복잡도**    | O(N)       | O(N)         |
| **추가 배열 사용** | Boolean 배열 | Int 배열 (입력용) |
| **패스 수**     | 2패스        | 1패스          |
| **가독성**      | 중간         | 높음           |
| **메모리 효율**   | 보통         | 양호           |

---

## 결론

### 이태호 방식의 장점

✅ 명확한 상태 관리  
✅ StreamTokenizer 사용으로 입력 처리 빠름

### 전효준 방식의 장점

✅ 한 번의 순회로 완성 (1-pass)  
✅ 코드가 더 직관적  
✅ 메모리 사용 패턴이 더 효율적

두 솔루션 모두 **O(N) 선형 시간**으로 효율적이며, 접근 방식만 다를 뿐 시간복잡도에는 큰 차이가 없음

